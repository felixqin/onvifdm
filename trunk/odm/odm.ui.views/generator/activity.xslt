<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet 
	version="2.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
	xmlns:msxsl="urn:schemas-microsoft-com:xslt" 
	exclude-result-prefixes="msxsl" >
	
	<xsl:output method="text"/>
	
<xsl:template match="/activity">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
]]>
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Reactive.Disposables;
using System.Windows.Input;
using odm.infra;
namespace <xsl:value-of select="@clr-ns" /> {
	<xsl:for-each select="use">
		<xsl:value-of select="concat('using global::', @clr-ns)" />;
	</xsl:for-each>
	public partial class <xsl:value-of select="@name" />{
		<xsl:apply-templates select="/activity/model" mode="generate-model"/>
		#region Result definition
		public abstract class Result{
			private Result() { }
			<xsl:apply-templates select="result" mode="generate-handle-function-decl"/>
			<xsl:for-each select="result/option">
			public bool <xsl:value-of select="concat('Is', @name)"/>(){
				return <xsl:value-of select="concat('As', @name)"/>() != null;
			}
			public virtual <xsl:value-of select="concat(@name, ' As', @name)"/>(){ return null; }
			public class <xsl:value-of select="@name"/> : Result {
				public <xsl:value-of select="@name"/>(<xsl:for-each select="param"><xsl:value-of select="concat(@clr-type,' ',@name)"/><xsl:if test="not(position()=last())">,</xsl:if></xsl:for-each>){
					<xsl:for-each select="param">
					this.<xsl:value-of select="concat(@name, ' = ', @name)"/>;
					</xsl:for-each>
				}
				<xsl:for-each select="param">
					<xsl:value-of select="concat('public ', @clr-type, ' ', @name, '{ get; set; }')"/>
				</xsl:for-each>
				public override <xsl:value-of select="concat(@name, ' As', @name)"/>(){ return this; }
				<xsl:apply-templates select="." mode="generate-handle-function-impl"/>
			}
			</xsl:for-each>
		}
		#endregion

		<!--#region Activity definition
		public static FSharpAsync&lt;Result&gt; Show(IUnityContainer container, Model model) {
			return ViewActivity.Create&lt;Model, Result=""&gt;
				(container, model, context => {
					var presenter = container.Resolve&lt;IViewPresenter&gt;();
					var view = new CreateProfileView(context);
					var disp = presenter.ShowView(view);
					return Disposable.Create(() => {
						disp.Dispose();
						view.Dispose();
					});
			});
		}
		#endregion-->
		
		<!-- generate commands -->
		<xsl:for-each select="result/option">
			<xsl:value-of select="concat('public ICommand ', @name, 'Command')"/>{ get; private set; }
		</xsl:for-each>
	
		<!-- generate fields -->
		IActivityContext&lt;Result&gt; activityContext = null;
		SingleAssignmentDisposable activityCancellationSubscription = new SingleAssignmentDisposable();
		bool activityCompleted = false;
		//activity has been completed
		event Action OnCompleted = null;
		//activity has been failed
		event Action&lt;Exception&gt; OnError = null;
		//activity has been completed successfully
		event Action&lt;Result&gt; OnSuccess = null;
		//activity has been canceled
		event Action OnCancelled = null;
		<!-- generate constructor -->
		public <xsl:value-of select="@name"/>(Model model, IActivityContext&lt;Result&gt; activityContext) {
			this.activityContext = activityContext;
			if(activityContext!=null){
				activityCancellationSubscription.Disposable = 
					activityContext.RegisterCancellationCallback(() => {
						EnsureAccess(() => {
							CompleteWith(() => {
								if(OnCancelled!=null){
									OnCancelled();
								}
							});
						});
					});
			}
			Init(model);
		}

		<!--  -->
		public void EnsureAccess(Action action){
			if(!CheckAccess()){
				Dispatcher.Invoke(action);
			}else{
				action();
			}
		}

		public void CompleteWith(Action cont){
			if(!activityCompleted){
				activityCompleted = true;
				cont();
				if(OnCompleted!=null){
					OnCompleted();
				}
				activityCancellationSubscription.Dispose();
			}
		}
		public void Success(Result result) {
			CompleteWith(() => {
				if(activityContext!=null){
					activityContext.Success(result);
				}
				if(OnSuccess!=null){
					OnSuccess(result);
				}
			});
		}
		public void Error(Exception error) {
			CompleteWith(() => {
				if(activityContext!=null){
					activityContext.Error(error);
				}
				if(OnError!=null){
					OnError(error);
				}
			});
		}
		public void Cancel() {
			CompleteWith(() => {
				if(activityContext!=null){
					activityContext.Cancel();
				}
				if(OnCancelled!=null){
					OnCancelled();
				}
			});
		}
		public void Success(Func&lt;Result&gt; resultFactory) {
			CompleteWith(() => {
				var result = resultFactory();
				if(activityContext!=null){
					activityContext.Success(result);
				}
				if(OnSuccess!=null){
					OnSuccess(result);
				}
			});
		}
		public void Error(Func&lt;Exception&gt; errorFactory) {
			CompleteWith(() => {
				var error = errorFactory();
				if(activityContext!=null){
					activityContext.Error(error);
				}
				if(OnError!=null){
					OnError(error);
				}
			});
		}
		public void Cancel(Action action) {
			CompleteWith(() => {
				action();
				if(activityContext!=null){
					activityContext.Cancel();
				}
				if(OnCancelled!=null){
					OnCancelled();
				}
			});
		}
		<!--protected virtual void OnCompleted() {
			//activity has been completed
		}
		protected virtual void OnCancel() {
			//activity has been canceled
		}
		protected virtual void OnSuccess(Result result) {
			context.Success(result);
		}
		protected virtual void OnError(Exception error) {
			context.Error(error);
		}-->
		
		<!--protected void Dispose() {
			CompleteWith(() => OnCancel());
		}-->
	}
}
</xsl:template>
	
	<xsl:template match="/activity/result" mode="generate-handle-function-decl">
			public abstract T Handle&lt;T&gt;(
				<xsl:for-each select="option">
					<xsl:variable name="name" select="concat(translate(substring(@name, 1, 1), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), substring(@name, 2))"/>
				Func&lt;<xsl:for-each select="param"><xsl:value-of select="@clr-type"/>,</xsl:for-each>T&gt; <xsl:value-of select="$name"/><xsl:if test="not(position()=last())">,</xsl:if>
				</xsl:for-each>
			);
	</xsl:template>
	
	<xsl:template match="/activity/result/option" mode="generate-handle-function-impl">
				<xsl:variable name="handler-to-invoke" select="concat(translate(substring(@name, 1, 1), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), substring(@name, 2))"/>	
				<xsl:variable name="result" select="parent::result"/>
				public override T Handle&lt;T&gt;(
				<xsl:for-each select="$result/option">
					<xsl:variable name="name" select="concat(translate(substring(@name, 1, 1), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), substring(@name, 2))"/>
					Func&lt;<xsl:for-each select="param"><xsl:value-of select="@clr-type"/>,</xsl:for-each>T&gt; <xsl:value-of select="$name"/><xsl:if test="not(position()=last())">,</xsl:if>
				</xsl:for-each>
				){
					return <xsl:value-of select="$handler-to-invoke"/>(
						<xsl:for-each select="param">
						<xsl:value-of select="@name"/><xsl:if test="not(position()=last())">,</xsl:if>
						</xsl:for-each>
					);
				}
	</xsl:template>
	
	<xsl:template match="/activity/model" mode="generate-model">
		<!-- all simple trackable properties -->
		<xsl:variable name="s-props" select="prop[not(@collection) and not(@read-only = 'true')]"/>
		<!-- all trackable collection properties -->
		<xsl:variable name="c-props" select="prop[(@collection = 'list') and not(@read-only = 'true')]"/>
		<!-- any not trackable properties -->
		<xsl:variable name="r-props" select="prop[@read-only = 'true']"/>
		<!-- any trackable properties s-props+c-props -->
		<xsl:variable name="t-props" select="prop[not(@read-only = 'true')]"/>
		<xsl:variable name="class-name">
			<xsl:if test="./@name"><xsl:value-of select="./@name"/></xsl:if>
			<xsl:if test="not(./@name)">Model</xsl:if>
		</xsl:variable>
		#region <xsl:value-of select="$class-name"/> definition
		<xsl:choose>
			<xsl:when test="$t-props">
		public interface IModelAccessor{
			<xsl:for-each select="$s-props">
				<xsl:value-of select="concat(@clr-type, ' ', @name)"/>{get;set;}
			</xsl:for-each>
			<xsl:for-each select="$c-props">
				<xsl:value-of select="concat('ObservableCollection&lt;',@clr-type, '&gt; ', @name)"/>{get;set;}
			</xsl:for-each>
		}
		public class <xsl:value-of select="$class-name"/>: IModelAccessor, INotifyPropertyChanged{
			<xsl:apply-templates select="." mode="generate-model-constructors"/>
			<xsl:for-each select="$s-props">
				private <xsl:value-of select="concat('SimpleChangeTrackable&lt;', @clr-type,'&gt; m_', @name,';')"/>
			</xsl:for-each>
			<xsl:for-each select="$c-props">
				private <xsl:value-of select="concat('ChangeTrackableCollection&lt;', @clr-type,'&gt; m_', @name,';')"/>
			</xsl:for-each>
			<xsl:for-each select="$r-props">
				public <xsl:value-of select="concat(@clr-type,' ', @name, '{get;private set;}')"/>
			</xsl:for-each>

			private class OriginAccessor: IModelAccessor {
				private <xsl:value-of select="$class-name"/> m_model;
				public OriginAccessor(<xsl:value-of select="$class-name"/> model) {
					m_model = model;
				}
				<xsl:for-each select="$s-props">
				<xsl:value-of select="concat(@clr-type, ' IModelAccessor.', @name)"/> {
					get {return m_model.m_<xsl:value-of select="@name"/>.origin;}
					set {m_model.m_<xsl:value-of select="@name"/>.origin = value;}
				}
				</xsl:for-each>
				<xsl:for-each select="$c-props">
				<xsl:value-of select="concat('ObservableCollection&lt;',@clr-type, '&gt; IModelAccessor.', @name)"/> {
					get {return m_model.m_<xsl:value-of select="@name"/>.origin;}
					set {m_model.m_<xsl:value-of select="@name"/>.origin = value;}
				}
				</xsl:for-each>
			}
			public event PropertyChangedEventHandler PropertyChanged;
			private void NotifyPropertyChanged(string propertyName){
				var prop_changed = this.PropertyChanged;
				if (prop_changed != null) {
					prop_changed(this, new PropertyChangedEventArgs(propertyName));
				}
			}
			<!--private class CurrentAccessor: <xsl:value-of select="$i-name"/> {
				private <xsl:value-of select="@name"/> m_model;
				public CurrentAccessor(<xsl:value-of select="@name"/> model) {
					m_model = model;
				}
				<xsl:for-each select="prop">
				<xsl:value-of select="concat(@clr-type, ' ', $i-name, '.', @name)"/>  {
					get {return m_model.m_<xsl:value-of select="@name"/>.current;}
					set {m_model.m_<xsl:value-of select="@name"/>.current = value;}
				}
				</xsl:for-each>
			}-->
			<xsl:for-each select="$s-props">
			public <xsl:value-of select="concat(@clr-type, ' ', @name)"/>  {
				get {return m_<xsl:value-of select="@name"/>.current;}
				set {
					if(m_<xsl:value-of select="@name"/>.current != value) {
						m_<xsl:value-of select="@name"/>.current = value;
						NotifyPropertyChanged(&quot;<xsl:value-of select="@name"/>&quot;);
					}
				}
			}
			</xsl:for-each>
			<xsl:for-each select="$c-props">
			public <xsl:value-of select="concat('ObservableCollection&lt;',@clr-type, '&gt; ', @name)"/>  {
				get {return m_<xsl:value-of select="@name"/>.current;}
				set {
					if(m_<xsl:value-of select="@name"/>.current != value) {
						m_<xsl:value-of select="@name"/>.current = value;
						NotifyPropertyChanged(&quot;<xsl:value-of select="@name"/>&quot;);
					}
				}
			}
			</xsl:for-each>
			public void AcceptChanges() {
				<xsl:for-each select="$t-props">
					<xsl:value-of select="concat('m_',@name,'.AcceptChanges()')"/>;
				</xsl:for-each>
			}

			public void RevertChanges() {
				<xsl:for-each select="$t-props">
					<xsl:value-of select="concat('this.current.', @name, '= this.origin.', @name)"/>;
				</xsl:for-each>
			}

			public bool isModified {
				get {
					<xsl:for-each select="$t-props">
					<xsl:value-of select="concat('if(m_', @name, '.isModified)')"/>return true;
					</xsl:for-each>
					return false;
				}
			}

			public IModelAccessor current {
				get {return this;}
				<!--set {throw new NotImplementedException();}-->
			}

			public IModelAccessor origin {
				get {return new OriginAccessor(this);}
				<!--set {throw new NotImplementedException();}-->
			}
		}
			</xsl:when>
			<xsl:otherwise>
		public class <xsl:value-of select="$class-name"/>{
			<xsl:apply-templates select="." mode="generate-model-constructors"/>
			<xsl:for-each select="$r-props">
			public <xsl:value-of select="concat(@clr-type,' ', @name,'{get;private set;}')"/>
			</xsl:for-each>
		}
			</xsl:otherwise>
		</xsl:choose>
		#endregion
	</xsl:template>

		<xsl:template match="/activity/model" mode="generate-model-constructors">
			<!-- all simple trackable properties -->
			<xsl:variable name="s-props" select="prop[not(@collection) and not(@read-only = 'true')]"/>
			<!-- all trackable collection properties -->
			<xsl:variable name="c-props" select="prop[(@collection = 'list') and not(@read-only = 'true')]"/>
			<!-- any not trackable properties -->
			<xsl:variable name="r-props" select="prop[@read-only = 'true']"/>
			<!-- any trackable properties s-props+c-props -->
			<xsl:variable name="t-props" select="prop[not(@read-only = 'true')]"/>
			<xsl:variable name="class-name">
				<xsl:if test="./@name"><xsl:value-of select="./@name"/></xsl:if>
				<xsl:if test="not(./@name)">Model</xsl:if>
			</xsl:variable>
		
			<xsl:if test="$r-props">
			public <xsl:value-of select="$class-name"/>(
				<xsl:for-each select="$r-props">
					<xsl:value-of select="concat(@clr-type, ' ', @name)"/>
					<xsl:if test="not(position()=last())">, </xsl:if>
				</xsl:for-each>
			){
				<xsl:for-each select="$r-props">
				this.<xsl:value-of select="concat(@name, ' = ', @name,';')"/>
				</xsl:for-each>
			}
			private <xsl:value-of select="$class-name"/>(){
			}
			</xsl:if>

			<xsl:if test="not($r-props)">
			public <xsl:value-of select="$class-name"/>(){
			}
			</xsl:if>

			public static <xsl:value-of select="$class-name"/> Create(
				<xsl:for-each select="./prop">
					<xsl:if test ="not(self::node()[@collection='list'])">
						<xsl:value-of select="concat(@clr-type, ' ', @name)"/>
					</xsl:if>
					<xsl:if test ="self::node()[@collection='list']">
						<xsl:value-of select="concat('ObservableCollection&lt;', @clr-type, '&gt; ', @name)"/>
					</xsl:if>
				<xsl:if test="not(position()=last())">,
				</xsl:if>
				</xsl:for-each>
			){
				var _this = new <xsl:value-of select="$class-name"/>();
				<xsl:for-each select="$r-props">
				_this.<xsl:value-of select="concat(@name, ' = ', @name,';')"/>
				</xsl:for-each>
				<xsl:for-each select="$t-props">
				_this.origin.<xsl:value-of select="concat(@name, ' = ', @name,';')"/>
				</xsl:for-each>
				<xsl:if test="$t-props">
				_this.RevertChanges();
				</xsl:if>
				return _this;
			}
		</xsl:template>

	<xsl:template match="@* | node()"/>
</xsl:stylesheet>
